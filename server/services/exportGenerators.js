import PDFDocument from 'pdfkit'
import PptxGenJS from 'pptxgenjs'
import { Document, Packer, Paragraph } from 'docx'
import archiver from 'archiver'

// For image export we will lazily import puppeteer (heavy) only if requested

// Generate filename from summary content
function generateFilename(summary, extension, customFilename = null) {
  // If custom filename is provided, use it with "by Mind-Mesh" suffix
  if (customFilename && typeof customFilename === 'string' && customFilename.trim()) {
    let cleanName = customFilename
      .trim()
      .toLowerCase()
      // Remove emojis and special unicode
      .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{FE00}-\u{FE0F}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]/gu, '')
      // Remove non-alphanumeric except spaces and hyphens
      .replace(/[^a-z0-9\s-]/g, '')
      // Replace spaces with hyphens
      .replace(/\s+/g, '-')
      // Remove consecutive hyphens
      .replace(/-+/g, '-')
      // Remove leading/trailing hyphens
      .replace(/^-+|-+$/g, '')
    
    // Add "by-mind-mesh" suffix if not already present
    if (!cleanName.includes('mind-mesh')) {
      cleanName = `${cleanName}-by-mind-mesh`
    }
    
    return `${cleanName}.${extension}`
  }
  
  // Auto-generate from summary content (max 15 characters)
  if (!summary || typeof summary !== 'string') {
    return `summary-by-mind-mesh.${extension}`
  }
  
  // Take first 15 characters, remove special chars, convert to kebab-case
  let title = summary
    .substring(0, 15)
    .trim()
    .toLowerCase()
    // Remove emojis and special unicode
    .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{FE00}-\u{FE0F}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]/gu, '')
    // Remove non-alphanumeric except spaces and hyphens
    .replace(/[^a-z0-9\s-]/g, '')
    // Replace spaces with hyphens
    .replace(/\s+/g, '-')
    // Remove consecutive hyphens
    .replace(/-+/g, '-')
    // Remove leading/trailing hyphens
    .replace(/^-+|-+$/g, '')
  
  // Fallback if title becomes empty
  if (!title || title.length < 3) {
    title = 'summary'
  }
  
  // Add "by-mind-mesh" suffix
  title = `${title}-by-mind-mesh`
  
  return `${title}.${extension}`
}

export async function generateOne(format, summaryObj, customFilename = null) {
  const { summary, highlights = [], metadata = {} } = summaryObj
  
  switch (format) {
    case 'txt': {
      const txtContent = `ðŸ“„ Mind-Mesh Summary\n${'='.repeat(50)}\n\n${summary}${highlights.length ? `\n\nðŸ” Key Highlights:\n${highlights.map((h, i) => `${i + 1}. ${h}`).join('\n')}` : ''}\n\n${'='.repeat(50)}\nGenerated by Mind-Mesh${metadata.generatedAt ? ` on ${new Date(metadata.generatedAt).toLocaleString()}` : ''}`
      return bufferResult(generateFilename(summary, 'txt', customFilename), 'text/plain', Buffer.from(txtContent, 'utf8'))
    }
    case 'pdf':
      return await generatePdf(summary, highlights, metadata, customFilename)
    case 'docx':
      return await generateDocx(summary, highlights, metadata, customFilename)
    case 'pptx':
      return await generatePptx(summary, highlights, metadata, customFilename)
    case 'png':
    case 'image':
      return await generateImage(summary, metadata, customFilename)
    default:
      throw new Error(`Unsupported format: ${format}`)
  }
}

export async function generateMany(formats, summaryObj) {
  if (formats.length === 1) return generateOne(formats[0], summaryObj)
  const archiveStream = archiver('zip', { zlib: { level: 9 } })
  const buffers = []
  const promise = new Promise((resolve, reject) => {
    archiveStream.on('warning', err => { if (err.code !== 'ENOENT') reject(err) })
    archiveStream.on('error', reject)
    archiveStream.on('data', d => buffers.push(d))
    archiveStream.on('end', () => resolve(Buffer.concat(buffers)))
  })

  for (const f of formats) {
    try {
      const { filename, buffer } = await generateOne(f, summaryObj)
      archiveStream.append(buffer, { name: filename })
    } catch (e) {
      const errMsg = `Failed to generate ${f}: ${e.message}`
      archiveStream.append(Buffer.from(errMsg), { name: `error-${f}.txt` })
    }
  }
  archiveStream.finalize()
  const zipBuffer = await promise
  return bufferResult('summary_bundle.zip', 'application/zip', zipBuffer)
}

// ---- Individual generators ----
async function generatePdf(summary, highlights, metadata = {}, customFilename = null) {
  const doc = new PDFDocument({ margin: 40 })
  const chunks = []
  doc.on('data', d => chunks.push(d))
  const done = new Promise(res => doc.on('end', res))
  
  // Remove emojis from all text content for PDF compatibility
  const cleanSummary = removeEmojis(summary)
  const cleanHighlights = highlights.map(h => removeEmojis(h))
  
  // Header
  doc.fontSize(24).text('Mind-Mesh Summary', { underline: true })
  doc.moveDown(0.5)
  
  // Metadata
  if (metadata.generatedAt) {
    doc.fontSize(10).fillColor('gray').text(`Generated: ${new Date(metadata.generatedAt).toLocaleString()}`, { align: 'right' })
    doc.moveDown(0.5)
  }
  
  // Summary content
  doc.fillColor('black').fontSize(16).text('Summary', { underline: true })
  doc.moveDown(0.5)
  doc.fontSize(12).text(cleanSummary, { align: 'left', lineGap: 2 })
  
  // Highlights
  if (cleanHighlights && cleanHighlights.length) {
    doc.moveDown().fontSize(16).text('Key Highlights', { underline: true })
    doc.moveDown(0.5)
    doc.fontSize(11)
    cleanHighlights.forEach((h, i) => {
      doc.text(`${i + 1}. ${h}`, { indent: 15, lineGap: 3 })
    })
  }
  
  // Footer
  doc.fontSize(8).fillColor('gray').text('Generated by Mind-Mesh', 40, doc.page.height - 40)
  
  doc.end()
  await done
  return bufferResult(generateFilename(summary, 'pdf', customFilename), 'application/pdf', Buffer.concat(chunks))
}

async function generateDocx(summary, highlights, metadata = {}, customFilename = null) {
  const paragraphs = []
  
  // Title
  paragraphs.push(new Paragraph({ text: 'ðŸ“„ Mind-Mesh Summary', heading: 'Title' }))
  
  // Metadata
  if (metadata.generatedAt) {
    paragraphs.push(new Paragraph({ 
      text: `Generated: ${new Date(metadata.generatedAt).toLocaleString()}`,
      style: 'Footer'
    }))
  }
  
  // Summary section
  paragraphs.push(new Paragraph({ text: 'Summary', heading: 'Heading1' }))
  paragraphs.push(new Paragraph(summary))
  
  // Highlights section
  if (highlights && highlights.length) {
    paragraphs.push(new Paragraph({ text: 'ðŸ” Key Highlights', heading: 'Heading1' }))
    highlights.forEach((h, i) => paragraphs.push(new Paragraph(`${i + 1}. ${h}`)))
  }
  
  // Footer
  paragraphs.push(new Paragraph({ 
    text: 'Generated by Mind-Mesh',
    style: 'Footer'
  }))
  
  const doc = new Document({ sections: [{ properties: {}, children: paragraphs }] })
  const buffer = await Packer.toBuffer(doc)
  return bufferResult(generateFilename(summary, 'docx', customFilename), 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', buffer)
}

async function generatePptx(summary, highlights, metadata = {}, customFilename = null) {
  const pptx = new PptxGenJS()
  pptx.author = 'Mind-Mesh'
  pptx.company = 'Mind-Mesh'
  pptx.title = 'AI Generated Summary'
  
  // Title slide
  const titleSlide = pptx.addSlide()
  titleSlide.addText('ðŸ“„ Mind-Mesh Summary', { 
    x: 1, y: 2, fontSize: 36, bold: true, color: '1F4788', align: 'center' 
  })
  titleSlide.addText('AI Generated Document Summary', { 
    x: 1, y: 3, fontSize: 18, color: '666666', align: 'center' 
  })
  if (metadata.generatedAt) {
    titleSlide.addText(`Generated: ${new Date(metadata.generatedAt).toLocaleString()}`, { 
      x: 1, y: 5.5, fontSize: 12, color: '999999', align: 'center' 
    })
  }
  
  // Summary slides
  const maxCharsPerSlide = 800
  const slidesData = chunkString(summary, maxCharsPerSlide)
  slidesData.forEach((chunk, idx) => {
    const slide = pptx.addSlide()
    slide.addText(idx === 0 ? 'ðŸ“‹ Summary' : `ðŸ“‹ Summary (${idx + 1}/${slidesData.length})`, { 
      x: 0.5, y: 0.3, fontSize: 28, bold: true, color: '1F4788' 
    })
    slide.addText(chunk, { 
      x: 0.5, y: 1.2, fontSize: 16, w: 9, h: 4.5, valign: 'top', lineSpacing: 24 
    })
  })
  
  // Highlights slide
  if (highlights && highlights.length) {
    const slide = pptx.addSlide()
    slide.addText('ðŸ” Key Highlights', { 
      x: 0.5, y: 0.3, fontSize: 28, bold: true, color: '1F4788' 
    })
    slide.addText(highlights.map((h, i) => `${i + 1}. ${h}`).join('\n\n'), { 
      x: 0.5, y: 1.2, fontSize: 16, w: 9, h: 5, valign: 'top', lineSpacing: 26 
    })
  }
  
  const buffer = await pptx.write('arraybuffer')
  return bufferResult(generateFilename(summary, 'pptx', customFilename), 'application/vnd.openxmlformats-officedocument.presentationml.presentation', Buffer.from(buffer))
}

async function generateImage(summary, metadata = {}, customFilename = null) {
  // Lazy require puppeteer to avoid overhead unless needed
  const puppeteer = await import('puppeteer')
  const browser = await puppeteer.launch({ headless: 'new' })
  const page = await browser.newPage()
  
  const generatedDate = metadata.generatedAt ? new Date(metadata.generatedAt).toLocaleString() : ''
  
  const html = `
    <html>
      <head>
        <style>
          body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            padding: 40px; 
            max-width: 800px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: 0;
          }
          .container {
            background: rgba(255,255,255,0.95);
            color: #333;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
          }
          .header { 
            text-align: center; 
            margin-bottom: 30px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 20px;
          }
          .title { 
            font-size: 32px; 
            font-weight: bold; 
            color: #667eea; 
            margin: 0 0 10px 0;
          }
          .subtitle { 
            font-size: 16px; 
            color: #666; 
            margin: 0;
          }
          .content { 
            line-height: 1.6; 
            white-space: pre-wrap; 
            font-size: 16px;
            text-align: justify;
          }
          .footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            color: #999;
            font-size: 12px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <div class="title">ðŸ“„ Mind-Mesh Summary</div>
            <div class="subtitle">AI Generated Document Summary</div>
            ${generatedDate ? `<div style="margin-top: 10px; font-size: 12px;">Generated: ${generatedDate}</div>` : ''}
          </div>
          <div class="content">${escapeHtml(summary)}</div>
          <div class="footer">Generated by Mind-Mesh</div>
        </div>
      </body>
    </html>`
  
  await page.setContent(html, { waitUntil: 'networkidle0' })
  await page.setViewport({ width: 800, height: 1000 })
  const buffer = await page.screenshot({ type: 'png', fullPage: true })
  await browser.close()
  return bufferResult(generateFilename(summary, 'png', customFilename), 'image/png', buffer)
}

// ---- Helpers ----
function bufferResult(filename, mime, buffer) {
  return { filename, mime, buffer }
}

function chunkString(str, size) {
  const out = []
  for (let i = 0; i < str.length; i += size) out.push(str.slice(i, i + size))
  return out
}

function escapeHtml(str='') {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
}

// Remove emojis and special unicode characters for PDF compatibility
function removeEmojis(str = '') {
  if (!str) return ''
  // Remove emojis, symbols, pictographs, transport symbols, flags, etc.
  return str.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{FE00}-\u{FE0F}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]/gu, '')
}

